Index: include/proc.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//\r\n// Created by Oniar_Pie on 2023/11/9.\r\n//\r\n\r\n#ifndef SRC_PROC_H\r\n#define SRC_PROC_H\r\n#pragma pack(1)\r\n#define MAX_PAGES_PROC 8\r\n#define MAX_TASKS 32\r\n#define TASK_EMPTY 0\r\n#define TASK_RUNNING 1\r\n#define TASK_READY 2\r\n#define TASK_SUSPENDED 3\r\n#define TASK_ZOMBIE 4\r\n#define MAX_PROC_COUNT 64\r\n#define MAX_UTIME 10\r\n#define MAX_PROC_OPENF 32\r\n#include \"gdt.h\"\r\n#include \"typename.h\"\r\n#include \"vfs.h\"\r\n\r\n#define CS_USER 0x30\r\n#define DS_USER 0x28\r\n#define _TSS_IND(n) (n*2+5)\r\n#define _LDT_IND(n) (n*2+6)\r\n// 下面是数学协处理器使用的结构，主要用于保存进程切换时i387 的执行状态信息。\r\nstruct i387_struct\r\n{\r\n    long cwd;\t\t\t// 控制字(Control word)。\r\n    long swd;\t\t\t// 状态字(Status word)。\r\n    long twd;\t\t\t// 标记字(Tag word)。\r\n    long fip;\t\t\t// 协处理器代码指针。\r\n    long fcs;\t\t\t// 协处理器代码段寄存器。\r\n    long foo;\r\n    long fos;\r\n    long st_space[20];\t\t/* 8*10 bytes for each FP-reg = 80 bytes */\r\n};\r\n\r\n#define HEAP_BASE 0x1000000\r\n#define HEAP_MAXTOP 0x1f00000\r\n#define CHUNK_SIZE 0x1000\r\n#define INT_STACK_TOP 0x800000\r\n#define INT_STACK_BASE 0x7ff000\r\n#define STACK_TOP 0x0000fffffffff000ul\r\n//堆空间\r\ntypedef struct _chunk_header_{\r\n    int pgn;    //占用页面数量\r\n    int alloc;  //是否被分配了\r\n    struct _chunk_header_* next;   //下一个存储头地址\r\n    struct _chunk_header_* prev;   //上一个存储头地址\r\n}chunk_header;\r\ntypedef struct _procm_{\r\n    int heap_base;\r\n    int heap_top;\r\n    int stack_bottom;\r\n    int stack_top;\r\n    int text_base;\r\n    int text_top;\r\n    int data_base;\r\n    int data_top;\r\n}proc_mem_arr;\r\ntypedef struct\r\n{\r\n    long cr3;\r\n    long rip;\r\n    long rflags;\r\n    long rax, rcx, rdx, rbx;\r\n    long rsp;\r\n    long rbp;\r\n    long rsi;\r\n    long rdi;\r\n    long es;\r\n    long cs;\r\n    long ss;\r\n    long ds;\r\n    long fs;\r\n    long gs;\r\n    long r8,r9,r10,r11,r12,r13,r14,r15;\r\n    long errcode;\r\n}regs_t;\r\n//在始终中断发生的时候，对栈里面保存现场用的入栈数据。此结构体用于创建进程时方便构建一个这样的现场。\r\ntypedef struct {\r\n    unsigned long ds,es,r15,r14,r13,r12,r11,r10,r9,r8;\r\n    unsigned long rsi,rdi,rdx,rcx,rbx,rax;\r\n    //iret使用\r\n    unsigned long rip,cs,rflags,rsp,ss;\r\n\r\n}stack_store_regs;\r\n\r\n#ifdef IA32\r\ntypedef struct REGISTERS\r\n{\r\n    long back_link;\t\t/* 16 high bits zero */\r\n    long esp0;\r\n    long ss0;\t\t\t/* 16 high bits zero */\r\n    long esp1;\r\n    long ss1;\t\t\t/* 16 high bits zero */\r\n    long esp2;\r\n    long ss2;\t\t\t/* 16 high bits zero */\r\n    long cr3;\r\n    long eip;\r\n    long eflags;\r\n    long eax, ecx, edx, ebx;\r\n    long esp;\r\n    long ebp;\r\n    long esi;\r\n    long edi;\r\n    long es;\t\t\t/* 16 high bits zero */\r\n    long cs;\t\t\t/* 16 high bits zero */\r\n    long ss;\t\t\t/* 16 high bits zero */\r\n    long ds;\t\t\t/* 16 high bits zero */\r\n    long fs;\t\t\t/* 16 high bits zero */\r\n    long gs;\t\t\t/* 16 high bits zero */\r\n    long ldt;\t\t\t/* 16 high bits zero *///ldt 段选择子\r\n    long trace_bitmap;\t\t/* bits: trace 0, bitmap 16-31 */\r\n    //struct i387_struct i387;\r\n}TSS;\r\nstruct process{\r\n    unsigned int pid;\r\n    unsigned int stat;\r\n    unsigned int utime; //used time\r\n    unsigned int priority;\r\n    unsigned int exit_code;//exit code\r\n\r\n    proc_mem_arr mem_struct;\r\n\r\n    descriptor ldt[5];\r\n    unsigned int has_console;\r\n    unsigned int parent_pid;\r\n    unsigned int page[8];\r\n    unsigned int *pdet;//页目录\r\n    vfs_dir_entry *cwd;\r\n    vfs_dir_entry *exef;\r\n    vfs_dir_entry *openf[MAX_PROC_OPENF];\r\n    TSS tss;\r\n}__attribute__((packed));//208 bytes\r\n#else\r\n\r\ntypedef struct\r\n{\r\n    u32 rsvd;\r\n    u64 rsp0;\r\n    u64 rsp1;\r\n    u64 rsp2;\r\n    u64 rsvd2;\r\n    u64 ists[7];\r\n    u64 rsvd3;\r\n    u32 rsvd4;\r\n    u32 io_map_base;\r\n}TSS;\r\nstruct process{\r\n    unsigned int pid,gpid,sid,fg_pgid;//fg_gid是foreground process group id\r\n    int in_bgpg;//是否在background process group id\r\n    int tty_fd;//控制台fd\r\n    unsigned int stat;\r\n    unsigned int utime; //used time\r\n    unsigned int priority;\r\n    unsigned int exit_code;//exit code\r\n\r\n    proc_mem_arr mem_struct;\r\n\r\n    descriptor ldt[5];\r\n    unsigned int has_console;\r\n    unsigned int parent_pid;\r\n    unsigned int page[8];\r\n    addr_t *pml4;//pml4\r\n    struct file *cwd;\r\n    struct file *exef;\r\n    struct file *openf[MAX_PROC_OPENF];\r\n    TSS tss;\r\n    regs_t regs;\r\n    struct List node;//本进程的节点\r\n    struct List *child_procs;//子进程\r\n}__attribute__((packed));//208 bytes\r\n#endif\r\ntypedef struct\r\n{\r\n    unsigned int proc_end_addr;\r\n    unsigned int argv;\r\n    unsigned int argc;\r\n}proc_ret_stack;\r\n\r\n__attribute__((__always_inline__))inline int do_syscall(int func,int a1,int a2,int a3,int a4,int a5,int a6){\r\n        asm volatile(\".byte 0x48\\n\"\r\n                 \"syscall\"::\"a\"(func),\"D\"(a1),\"S\"(a2),\"d\"(a3),\"c\"(a4),\"r\"(a5),\"r\"(a6));\r\n}\r\n\r\nvoid init_proc();\r\nint req_proc();\r\nint reg_proc(addr_t entry, struct index_node *cwd, struct index_node *exef);\r\nvoid set_proc(long rax, long rbx, long rcx, long rdx, long es, long cs, long ss, long ds, long fs, long gs, long rsp,\r\n              long rbp, long rsi, long rdi, long rip, long rflags, int proc_nr);\r\nvoid manage_proc();\r\nvoid switch_proc_tss(int pnr);\r\n//tss_ind:tss在gdt中的索引\r\nvoid switch_proc_asm(int tss_ind);\r\nvoid del_proc(int pnr);\r\nint set_proc_stat(int pid,int stat);\r\n//内核将dll加载到指定地方\r\nint load_dll_at(char *path,int addr);\r\n\r\nint add_proc_openf(struct index_node *entry);\r\n\r\nint sys_exit(int code);\r\n\r\n\r\nvoid * sys_malloc(int size);\r\nint sys_free(int ptr);\r\n//弃用区=========================================\r\n//创建一个进程，返回进程在task数组中的index\r\nint create_zero();\r\n//创建一个零号进程为默认值的进程。\r\nint create_proc();\r\n//void fill_desc(u32 addr,u32 limit,u32 attr,unsigned long long* des);\r\nvoid switch_proc(int pnr);\r\nvoid switch_to_ia32(TSS *tss);\r\nvoid switch_to(struct process *from, struct process *to);\r\nvoid __switch_to(struct process *from, struct process *to);\r\n\r\nvoid save_context(TSS *tss);\r\n//用来保存rsp到当前proc.regs\r\nvoid save_rsp();\r\nvoid proc_zero();\r\nvoid proc_end();\r\nvoid* malloc(int size);\r\nvoid* palloc(int proc_index,int size);\r\n\r\n//设置TSS中的值。\r\nvoid set_tss(u64 rsp0,u64 rsp1,u64 rsp2,u64 ist0,u64 ist1,u64 ist2,u64 ist3,u64 ist4,u64 ist5,u64 ist6);\r\n\r\nvoid create_test_proc();\r\n\r\n\r\nvoid ret_sys_call();\r\nvoid ret_normal_proc();\r\nint sys_fork(void);\r\n\r\nvoid copy_mmap(struct process* from, struct process *to);\r\nvoid release_mmap(struct process* p);\r\nextern struct process* current;\r\n#endif //SRC_PROC_H\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/proc.h b/include/proc.h
--- a/include/proc.h	
+++ b/include/proc.h	
@@ -41,7 +41,7 @@
 #define CHUNK_SIZE 0x1000
 #define INT_STACK_TOP 0x800000
 #define INT_STACK_BASE 0x7ff000
-#define STACK_TOP 0x0000fffffffff000ul
+#define STACK_TOP 0x00007ffffffff000ul
 //堆空间
 typedef struct _chunk_header_{
     int pgn;    //占用页面数量
@@ -50,14 +50,14 @@
     struct _chunk_header_* prev;   //上一个存储头地址
 }chunk_header;
 typedef struct _procm_{
-    int heap_base;
-    int heap_top;
-    int stack_bottom;
-    int stack_top;
-    int text_base;
-    int text_top;
-    int data_base;
-    int data_top;
+    addr_t heap_base;
+    addr_t heap_top;
+    addr_t stack_bottom;
+    addr_t stack_top;
+    addr_t text_base;
+    addr_t text_top;
+    addr_t data_base;
+    addr_t data_top;
 }proc_mem_arr;
 typedef struct
 {
@@ -210,7 +210,7 @@
 //创建一个进程，返回进程在task数组中的index
 int create_zero();
 //创建一个零号进程为默认值的进程。
-int create_proc();
+int set_proc0();
 //void fill_desc(u32 addr,u32 limit,u32 attr,unsigned long long* des);
 void switch_proc(int pnr);
 void switch_to_ia32(TSS *tss);
